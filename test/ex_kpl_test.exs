defmodule ExKplTest do
  @moduledoc """
  Expected data generated by `priv/kpl_agg_tests_helper.py`
  """

  use ExUnit.Case
  use Bitwise

  doctest ExKpl

  @magic <<243, 137, 154, 194>>
  @magic_deflated <<244, 137, 154, 194>>
  @max_bytes_per_record bsl(1, 20)

  test "empty aggregator" do
    agg = ExKpl.new()
    size = ExKpl.size_bytes(agg)

    assert 0 == ExKpl.count(agg)
    assert 16 + 4 == size
    assert {:undefined, %ExKpl{}} = ExKpl.finish(agg)
  end

  test "basic aggregation example" do
    agg = ExKpl.new()
    {:undefined, agg} = ExKpl.add(agg, {"pk1", "data1", "ehk1"})
    {:undefined, agg} = ExKpl.add(agg, {"pk2", "data2", "ehk2"})
    assert agg.num_user_records == 2
    {aggregated_record, agg} = ExKpl.finish(agg)
    assert 0 == ExKpl.count(agg)
    expected_pk = "pk1"
    expected_ehk = "ehk1"

    expected_data =
      @magic <>
        <<10, 3, 112, 107, 49, 10, 3, 112, 107, 50, 18, 4, 101, 104, 107, 49, 18, 4, 101, 104,
          107, 50, 26, 11, 8, 0, 16, 0, 26, 5, 100, 97, 116, 97, 49, 26, 11, 8, 1, 16, 1, 26, 5,
          100, 97, 116, 97, 50, 244, 41, 93, 155, 173, 190, 58, 30, 240, 223, 216, 8, 26, 205, 86,
          4>>

    assert {^expected_pk, ^expected_data, ^expected_ehk} = aggregated_record
  end

  test "shared keys" do
    [aggregated_record] =
      aggregate_many([
        {"alpha", "data1", "zulu"},
        {"beta", "data2", "yankee"},
        {"alpha", "data3", "xray"},
        {"charlie", "data4", "yankee"},
        {"beta", "data5", "zulu"}
      ])

    expected_pk = "alpha"
    expected_ehk = "zulu"

    expected_data =
      @magic <>
        <<10, 5, 97, 108, 112, 104, 97, 10, 4, 98, 101, 116, 97, 10, 7, 99, 104, 97, 114, 108,
          105, 101, 18, 4, 122, 117, 108, 117, 18, 6, 121, 97, 110, 107, 101, 101, 18, 4, 120,
          114, 97, 121, 26, 11, 8, 0, 16, 0, 26, 5, 100, 97, 116, 97, 49, 26, 11, 8, 1, 16, 1, 26,
          5, 100, 97, 116, 97, 50, 26, 11, 8, 0, 16, 2, 26, 5, 100, 97, 116, 97, 51, 26, 11, 8, 2,
          16, 1, 26, 5, 100, 97, 116, 97, 52, 26, 11, 8, 1, 16, 0, 26, 5, 100, 97, 116, 97, 53,
          78, 67, 160, 206, 22, 1, 33, 154, 3, 6, 110, 235, 9, 229, 53, 100>>

    assert {^expected_pk, ^expected_data, ^expected_ehk} = aggregated_record
  end

  test "record fullness" do
    data1 = String.duplicate("X", 500_000)
    data2 = String.duplicate("Y", 600_000)
    data3 = String.duplicate("Z", 200_000)

    agg = ExKpl.new()
    {:undefined, agg} = ExKpl.add(agg, {"pk1", data1, "ehk1"})
    {{agg_pk1, agg_data1, agg_ehk1}, agg} = ExKpl.add(agg, {"pk2", data2, "ehk2"})
    {:undefined, agg} = ExKpl.add(agg, {"pk3", data3, "ehk3"})
    {{agg_pk2, agg_data2, agg_ehk2}, _agg} = ExKpl.finish(agg)

    checksum1 = <<198, 6, 88, 216, 8, 244, 159, 59, 223, 14, 247, 208, 138, 137, 64, 118>>
    checksum2 = <<89, 148, 130, 126, 150, 23, 148, 18, 38, 230, 176, 182, 93, 186, 150, 69>>
    assert checksum1 == :crypto.hash(:md5, agg_data1)
    assert checksum2 == :crypto.hash(:md5, agg_data2)

    assert "pk1" = agg_pk1
    assert "ehk1" = agg_ehk1

    assert "pk2" = agg_pk2
    assert "ehk2" = agg_ehk2
  end

  test "full record" do
    {pk, data, _} = fill({:undefined, ExKpl.new()})
    total_size = byte_size(pk) + byte_size(data)
    assert total_size <= @max_bytes_per_record
    assert 99 <= total_size / @max_bytes_per_record * 100
  end

  test "max record size is configurable" do
    data = String.duplicate("X", 500)
    agg = ExKpl.new(max_bytes_per_record: 520)

    assert {:undefined, agg} = ExKpl.add(agg, {"pk", data, "ehk"})
    assert {{_pk, _agg_record_1, _}, agg} = ExKpl.add(agg, {"pk", data, "ehk"})
    assert {{_pk, _agg_record_2, _}, agg} = ExKpl.add(agg, {"pk", data, "ehk"})
    assert {{_pk, _agg_record_3, _}, agg} = ExKpl.finish(agg)
  end

  test "deflate" do
    agg = ExKpl.new()
    {:undefined, agg} = ExKpl.add(agg, {"pk1", "data1", "ehk1"})
    {{_, data_with_magic, _}, _} = ExKpl.finish(agg, true)
    <<magic::binary-size(4), data::binary()>> = data_with_magic
    assert ^magic = @magic_deflated
    inflated = :zlib.uncompress(data)
    data_length = String.length(inflated)
    proto = String.slice(inflated, 0, data_length - 16)
    checksum = String.slice(inflated, data_length - 16, data_length)
    assert ^checksum = :crypto.hash(:md5, proto)
    %ExKpl.Proto.AggregatedRecord{records: [record]} = ExKpl.Proto.AggregatedRecord.decode(proto)
    %ExKpl.Proto.Record{data: data} = record
    assert "data1" = data
  end

  test "record that is too large" do
    too_big = String.duplicate("A", @max_bytes_per_record + 1)
    agg = ExKpl.new()
    assert {:undefined, ^agg} = ExKpl.add(agg, {"pk1", too_big, "ehk1"})
  end

  defp fill({:undefined, agg}) do
    pk = Integer.to_string(:rand.uniform(1_000))

    data =
      :rand.uniform(1_000)
      |> Integer.to_string()
      |> String.duplicate(10)

    case ExKpl.add(agg, {pk, data}) do
      {:undefined, agg} -> fill({:undefined, agg})
      {full, _} -> full
    end
  end

  defp fill(full_record_and_agg), do: full_record_and_agg

  defp aggregate_many(records) do
    {agg_records, agg} = ExKpl.add_all(ExKpl.new(), records)

    case ExKpl.finish(agg) do
      {:undefined, _} -> agg_records
      {last_agg_record, _} -> agg_records ++ [last_agg_record]
    end
  end
end
